LibreOffice AI Writing Assistant: Production Integration Requirements Document

CLEAR OBJECTIVE
Implement the complete production-ready integration between LibreOffice Writer's AI sidebar chat interface and the LangGraph multi-agent system, enabling seamless user-to-document modification flow without PyUNO dependencies. The system must extract document context in C++ using native UNO APIs, communicate with Python agents via HTTP, and execute returned operations directly through LibreOffice's UNO framework.

Success criteria: User types message in AIPanel → AgentCoordinator extracts document context → HTTP request to Python agents → Multi-agent processing returns operations → DocumentOperations executes UNO modifications → User sees both chat response and document changes.

CONTEXT
The LibreOffice AI Writing Assistant integration is 90% complete with sophisticated architecture already implemented. The system uses a two-layer approach where C++ handles all LibreOffice-specific operations (UI, document access, UNO operations) while Python manages AI processing through specialized agents (DocumentMaster, ContentAgent, ResearchAgent, FormattingAgent, ExecutionAgent).

Current Working Infrastructure:
- Complete AIPanel sidebar chat interface in sw/source/ui/sidebar/ai/AIPanel.cxx with message queuing, background processing, and response display
- Full AgentCoordinator service in sw/source/core/ai/AgentCoordinator.cxx with request routing (simple/moderate/complex complexity analysis), operation translation framework, and response parsing
- Fully functional Python multi-agent system in langgraph-agents/ with bridge.py providing HTTP endpoints, state management, and agent orchestration
- DocumentOperations UNO service in sw/source/core/ai/operations/DocumentOperations.cxx with SwWrtShell integration for text insertion, formatting, and table operations
- Complete UNO service registration in sw/util/sw.component with proper service declarations
- NetworkClient interface definition in sw/source/core/ai/NetworkClient.hxx with HttpRequest/HttpResponse structures

Architecture Decision: No PyUNO dependency required. Document context extraction happens in C++ using SwWrtShell/SwDoc native access, serialized to JSON for HTTP transport to Python agents, with operation execution performed by C++ UNO services. This eliminates deployment complexity while maintaining full functionality and performance.

Python Agent System (Fully Functional):
The langgraph-agents system provides complete multi-agent processing with three complexity tiers. All Python infrastructure is working including bridge.py with FastAPI endpoints at /api/simple, /api/moderate, /api/complex, state management with EnhancedDocumentStateManager, and comprehensive agent coordination. The bridge layer includes _convert_cpp_context_to_document_state() for parsing C++ JSON context and _convert_agent_state_to_libreoffice_format() for generating operation responses.

C++ Integration Layer (90% Complete):
The LibreOffice C++ integration provides complete UI and framework infrastructure. AIPanel.cxx implements full chat interface with OnSendMessage() → queueMessage() → sendMessageToBackend() → processUserRequest() flow. AgentCoordinator.cxx provides complete orchestration framework with analyzeRequestComplexity(), parseEnhancedJsonResponse(), translateOperationsToUno(), executeTranslatedOperations(), and executeSingleOperation() methods. DocumentOperations.cxx implements core UNO operations with SwWrtShell integration.

Network Communication Architecture:
The system uses HTTP POST requests with JSON payloads for C++ to Python communication. AgentCoordinator sends document context and user message to localhost:8000/api/{complexity} endpoints. Python agents process requests and return JSON responses containing both chat content and operation arrays. The C++ layer parses responses and executes operations through the DocumentOperations service.

CONSTRAINTS
Technical Constraints:
- Must use LibreOffice's native UNO APIs exclusively for document operations - no external libraries
- HTTP communication must use LibreOffice's UCB (Universal Content Broker) system for network requests
- All C++ implementations must follow LibreOffice coding standards and error handling patterns
- JSON serialization in C++ must use OUString and OUStringBuffer for string handling
- SwWrtShell access must be obtained through proper view hierarchy (SwView → SwWrtShell)
- UNO service implementations must properly handle Reference lifecycle and exception propagation
- Network timeouts and error recovery must be implemented for production reliability

Business Constraints:
- Zero PyUNO dependency to eliminate deployment complexity and security concerns
- Maintain backward compatibility with existing LibreOffice Writer functionality
- Support undo/redo integration for all AI-generated document modifications
- Preserve existing user interface patterns and behavior expectations
- Enable future scalability by supporting remote Python agent deployment

Performance Constraints:
- Simple operations must complete within 2 seconds end-to-end
- Moderate operations must complete within 4 seconds
- Complex operations must complete within 5 seconds
- Document context extraction must not block UI thread
- HTTP requests must be asynchronous with proper error handling
- Memory usage must remain within LibreOffice's standard resource limits

Security Constraints:
- All network communication occurs over localhost only in current implementation
- JSON parsing must validate structure to prevent injection attacks
- Document context must not include sensitive user information beyond what's necessary for AI processing
- Agent responses must be validated before executing operations on documents
- Error messages must not expose internal system details to users

REASONING
The architecture eliminates PyUNO dependency by leveraging LibreOffice's existing C++ UNO infrastructure for both document access and operation execution. This approach provides several critical advantages:

Performance Benefits: Direct C++ UNO operations execute significantly faster than Python bridge alternatives. SwWrtShell provides immediate document access without serialization overhead, while DocumentOperations can execute modifications directly through the UNO framework without additional translation layers.

Deployment Simplification: Removing PyUNO dependency eliminates complex Python-LibreOffice bridge configuration, version compatibility issues, and additional security considerations. The system requires only standard LibreOffice installation plus separate Python agent server.

Architectural Clarity: Clear separation between C++ document operations and Python AI processing creates maintainable boundaries. C++ handles all LibreOffice-specific functionality while Python focuses exclusively on AI agent coordination and content generation.

Scalability Design: HTTP-based communication enables future deployment of Python agents on separate servers for load balancing. The JSON interface provides clean protocol for scaling agent processing independently of LibreOffice instances.

The implementation leverages LibreOffice's UCB system for HTTP communication, ensuring compatibility with existing network infrastructure and proxy configurations. JSON serialization uses OUString manipulation for efficient string handling within LibreOffice's memory management patterns.

Error handling follows LibreOffice's exception propagation model with proper UNO exception types. The AgentCoordinator provides centralized error recovery with fallback mechanisms for network failures and malformed responses.

DETAILED NETWORK FLOW AND IMPLEMENTATION SPECIFICATIONS

Phase 1: User Interaction and Context Preparation
The interaction begins in AIPanel.cxx when the user sends a message through the chat interface. The OnSendMessage() method at line 1170 triggers the following sequence:

1. Message Queuing: OnSendMessage() calls queueMessage() which adds the user input to m_aMessageQueue and starts background processing with startBackgroundProcessing()

2. Background Processing: startBackgroundProcessing() launches processMessageQueue() in a separate thread to handle communication without blocking the UI

3. Context Preparation: processMessageQueue() calls prepareDocumentContext() at line 312 which creates a PropertyValue sequence containing XTextDocument reference, XFrame reference, current selection state, and document properties

4. Backend Communication: sendMessageToBackend() is called with the user message and prepared context, which forwards to AgentCoordinator's processUserRequest() method

The current prepareDocumentContext() implementation at lines 312-356 provides basic context including document and frame references. Enhancement is needed to include cursor position, selected text, document structure information, and current formatting state for comprehensive agent processing.

Phase 2: Agent Coordination and Request Analysis
AgentCoordinator.cxx receives the request through processUserRequest() and performs the following operations:

1. Complexity Analysis: analyzeRequestComplexity() at line 535 analyzes the user message to determine routing to simple, moderate, or complex agent endpoints based on request characteristics

2. Context Extraction: extractDocumentContext() at lines 602-607 is called to serialize document context to JSON format. Currently this contains a stub implementation that returns input unchanged - this is GAP 1 requiring immediate implementation

3. Request Construction: The system prepares an HTTP POST request with JSON payload containing the user message and serialized document context

4. Network Communication: HTTP request is sent to localhost:8000/api/{complexity} using NetworkClient infrastructure

The extractDocumentContext() method must be implemented to extract comprehensive document information using SwWrtShell access. Implementation requires obtaining SwView through GetActiveView(), accessing SwWrtShell for cursor position with GetLineNum()/GetColumnNum(), extracting selected text with GetSelText(), and gathering document structure through SwDoc node traversal.

Phase 3: HTTP Communication Infrastructure
NetworkClient.cxx provides the HTTP communication layer with interfaces defined in NetworkClient.hxx at lines 75-85. The HttpResponse structure contains status code, response body, headers map, success flag, and error message.

Current HTTP Implementation Gap:
The NetworkClient interface exists but lacks complete implementation. Required implementation must use LibreOffice's UCB (Universal Content Broker) system for HTTP requests to maintain compatibility with LibreOffice's network infrastructure.

HTTP Request Construction:
1. URL Formation: Requests target localhost:8000/api/simple, localhost:8000/api/moderate, or localhost:8000/api/complex based on complexity analysis

2. JSON Payload: POST body contains structured JSON with "message" field containing user input and "context" field containing serialized document information from extractDocumentContext()

3. Headers: Content-Type set to application/json with additional headers for request identification

4. UCB Integration: Implementation must create XContent using UCB content provider, configure PostCommandArgument2 with JSON input stream, and execute post command through content interface

Network Error Handling:
The implementation must handle connection failures, timeout scenarios, malformed responses, and HTTP error codes. Error recovery includes retry logic for temporary failures and fallback to simplified processing when agents are unavailable.

Phase 4: Python Agent Processing Architecture
The Python agent system receives HTTP requests at bridge.py endpoints and processes them through the multi-agent architecture:

Agent Routing:
- /api/simple: Single-agent processing for basic text operations and formatting
- /api/moderate: Multi-agent coordination for content generation and document analysis
- /api/complex: Full agent orchestration for research, planning, and comprehensive document operations

Agent Processing Flow:
1. Context Conversion: _convert_cpp_context_to_document_state() parses JSON context from C++ layer and creates DocumentState for agent processing

2. Agent Coordination: Requests flow through DocumentMaster → ContentAgent → ResearchAgent → FormattingAgent → ExecutionAgent based on complexity requirements

3. State Management: EnhancedDocumentStateManager maintains document context and agent coordination state throughout processing

4. Operation Generation: Agents generate operation arrays containing specific UNO operations with parameters for document modification

5. Response Formation: _convert_agent_state_to_libreoffice_format() creates JSON response containing chat content and operation arrays for C++ execution

The bridge.py implementation at lines 234-292 provides complete HTTP endpoint handling with proper error management and state conversion. Agent coordination is fully functional with sophisticated state management and operation generation capabilities.

Phase 5: Response Processing and Operation Translation
AgentCoordinator.cxx receives the HTTP response and processes it through several translation stages:

1. Response Parsing: parseEnhancedJsonResponse() at line 674 parses the JSON response to extract chat content and operation arrays

2. Operation Translation: translateOperationsToUno() converts JSON operation specifications to C++ UNO operation parameters

3. Operation Execution: executeTranslatedOperations() iterates through operations and calls DocumentOperations service methods

4. Single Operation Handling: executeSingleOperation() manages individual operation execution with error handling and undo integration

The operation translation framework supports multiple operation types including text insertion, formatting application, table creation, and structural modifications. Each operation type has specific parameter mapping from JSON to UNO interfaces.

Phase 6: Document Operations and UNO Integration
DocumentOperations.cxx provides the UNO service implementation for executing operations on documents:

Core Operations Implementation:
1. Text Operations: insertText() at lines 190-253 uses SwWrtShell for direct text insertion with cursor positioning and undo integration

2. Formatting Operations: formatText() at lines 255-298 applies formatting through text cursor manipulation and property setting

3. Table Operations: createTable() and related methods use SwWrtShell table insertion with property configuration

4. Advanced Operations: Framework exists for chart insertion, complex formatting, and document structure modifications

SwWrtShell Integration:
The service obtains SwWrtShell through getWriterShell() helper method which accesses the active view and writer shell. Operations are executed directly through SwWrtShell methods ensuring immediate document updates and proper integration with LibreOffice's editing framework.

Undo Integration:
Each operation is wrapped with undo group creation using SwUndoManager to enable proper undo/redo functionality. Operations are recorded with descriptive names and complete parameter preservation for rollback capabilities.

Error Handling:
Operations include comprehensive error checking for invalid parameters, document state verification, and exception propagation through UNO RuntimeException mechanisms. Failed operations trigger appropriate error messages and maintain document consistency.

Phase 7: Response Display and User Feedback
The response processing concludes with user interface updates in AIPanel.cxx:

1. Response Reception: handleBackendResponse() receives the combined agent response containing both chat content and operation confirmations

2. Content Extraction: parseAndDisplayEnhancedResponse() extracts the chat portion of the response for display in the conversation interface

3. Operation Feedback: Operation execution results are displayed as confirmation messages showing what modifications were performed

4. Error Display: Any operation failures or network errors are presented to the user with appropriate recovery suggestions

The chat interface maintains conversation history and provides visual feedback during processing with loading indicators and progress updates.

IMPLEMENTATION GAPS AND SPECIFIC TECHNICAL REQUIREMENTS

GAP 1: C++ Document Context Extraction (CRITICAL)
Location: sw/source/core/ai/AgentCoordinator.cxx:602-607
Current Status: Stub implementation returning input unchanged
Required Implementation:

The extractDocumentContext() method must serialize comprehensive document information to JSON using native UNO access:

1. SwWrtShell Access: Obtain active SwView through GetActiveView() and access SwWrtShell for document operations

2. Cursor Information: Extract cursor position using GetLineNum() and GetColumnNum(), current selection with GetSelText(), and navigation state

3. Document Structure: Gather paragraph count, section information, and document hierarchy through SwDoc node traversal

4. Formatting State: Extract current character and paragraph formatting properties at cursor location

5. JSON Serialization: Use OUStringBuffer for efficient string building with proper JSON escaping and structure

Implementation must handle edge cases including empty documents, complex selections, and invalid document states. Error handling requires graceful degradation with minimal context when full extraction fails.

GAP 2: NetworkClient HTTP Implementation (CRITICAL)
Location: sw/source/core/ai/NetworkClient.cxx
Current Status: Interface exists, implementation incomplete
Required Implementation:

The postJson() method must implement complete HTTP POST functionality using LibreOffice's UCB system:

1. UCB Content Creation: Use createContent() to establish UCB content for target URL with proper error handling

2. POST Configuration: Create PostCommandArgument2 with JSON input stream and output sink configuration

3. Header Management: Set Content-Type to application/json and configure additional headers through PropertyValue sequences

4. Command Execution: Execute post command through XContent interface with proper timeout and error handling

5. Response Processing: Extract response body, status code, and headers from UCB response structures

Implementation must handle network timeouts, connection failures, and malformed responses. UCB integration ensures compatibility with LibreOffice's proxy and security configurations.

GAP 3: Enhanced AIPanel Context Preparation (MODERATE)
Location: sw/source/ui/sidebar/ai/AIPanel.cxx:312-356
Current Status: Basic PropertyValue sequence with minimal context
Required Enhancement:

The prepareDocumentContext() method must provide comprehensive document information:

1. Selection Enhancement: Extract detailed selection information including text content, formatting properties, and structural context

2. Document Properties: Include document metadata, language settings, and user preferences relevant to AI processing

3. View State: Capture current view configuration, zoom level, and cursor context for accurate operation placement

4. Content Analysis: Provide surrounding text context and document structure information for intelligent agent processing

Enhancement maintains existing PropertyValue structure while expanding available information for agent decision-making.

GAP 4: DocumentOperations Implementation Verification (MODERATE)
Location: sw/source/core/ai/operations/DocumentOperations.cxx
Current Status: Core operations implemented, some may need completion
Required Verification:

Complete testing and implementation verification for all operation types:

1. Text Operations: Verify insertText() and formatText() handle all parameter combinations and edge cases

2. Table Operations: Test createTable() with complex configurations and data population scenarios

3. Advanced Operations: Implement and test chart insertion, complex styling, and document structure modifications

4. Error Recovery: Ensure all operations properly handle failures and maintain document consistency

Testing must cover operation parameter validation, UNO interface compliance, and integration with LibreOffice's undo/redo system.

NETWORK PROTOCOL SPECIFICATIONS

HTTP Request Format:
POST /api/{complexity} HTTP/1.1
Host: localhost:8000
Content-Type: application/json
Content-Length: {length}

{
  "message": "user input text",
  "context": {
    "cursor_position": {"line": 15, "column": 42},
    "selected_text": "selected content",
    "document_structure": {"paragraph_count": 25},
    "formatting_state": {"font": "Arial", "size": 12}
  }
}

HTTP Response Format:
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: {length}

{
  "content": "agent response text",
  "operations": [
    {
      "type": "insertText",
      "parameters": {
        "text": "insertion content",
        "position": {"type": "cursor"}
      }
    },
    {
      "type": "formatText",
      "parameters": {
        "range": {"start": 0, "length": 10},
        "format": {"bold": true, "italic": false}
      }
    }
  ]
}

Error Response Format:
HTTP/1.1 500 Internal Server Error
Content-Type: application/json

{
  "error": "error description",
  "details": "additional error information",
  "recovery": "suggested user action"
}

CODEBASE ANALYSIS AND CURRENT IMPLEMENTATION STATUS

Working Components (90% Complete):
1. AIPanel User Interface: Complete chat interface with message handling, background processing, and response display in sw/source/ui/sidebar/ai/AIPanel.cxx

2. AgentCoordinator Framework: Complete orchestration service with request routing, response parsing, and operation translation in sw/source/core/ai/AgentCoordinator.cxx

3. Python Agent System: Fully functional multi-agent processing with bridge.py providing HTTP endpoints and agent coordination in langgraph-agents/

4. DocumentOperations Service: Core UNO operations implemented with SwWrtShell integration for text and formatting operations in sw/source/core/ai/operations/DocumentOperations.cxx

5. Service Registration: Proper UNO component registration in sw/util/sw.component enabling service discovery and instantiation

Critical Implementation Gaps:
1. Context extraction serialization in AgentCoordinator.cxx requiring SwWrtShell integration and JSON generation

2. HTTP client implementation in NetworkClient.cxx requiring UCB integration and proper error handling

3. Enhanced context preparation in AIPanel.cxx for comprehensive document information

4. Operation implementation verification in DocumentOperations.cxx ensuring all operation types function correctly

The implementation represents a sophisticated integration architecture with clear separation of concerns between C++ LibreOffice operations and Python AI processing. The HTTP bridge provides clean interface for scaling and maintenance while eliminating PyUNO deployment complexity.

SUCCESS CRITERIA AND VALIDATION REQUIREMENTS

Functional Validation:
1. Complete end-to-end flow from user message to document modification
2. Proper context extraction providing sufficient information for intelligent agent responses
3. Reliable HTTP communication with error recovery and timeout handling
4. Accurate operation execution with undo/redo integration
5. Appropriate user feedback for all operation results and error conditions

Performance Validation:
1. Simple operations completing within 2-second target
2. Moderate operations completing within 4-second target
3. Complex operations completing within 5-second target
4. Responsive UI during background processing
5. Efficient memory usage without leaks or excessive allocation

Integration Validation:
1. Compatibility with existing LibreOffice functionality
2. Proper UNO service lifecycle management
3. Correct error propagation and handling
4. Seamless integration with document editing workflows
5. Preservation of user preferences and document state

The implementation provides production-ready architecture for LibreOffice AI Writing Assistant with sophisticated multi-agent processing capabilities while maintaining LibreOffice's performance and integration standards.